/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package Abstractor;

import Abstractor.Astar.Astar;
import Abstractor.Astar.RiskNode;
import Concepts.Person;
import Core.Actuator;
import ImageAnalyzers.ImageManipulator;
import State.MapData;
import State.MapState;
import State.ViewState;
import Utilities.Mathematician;
import java.awt.Color;
import java.awt.Point;
import java.awt.image.BufferedImage;
import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.Random;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 *
 * @author James
 */
public class RiskMap {

          static ArrayList<PointValue> dangerPoints = new ArrayList<>();
          static ArrayList<PointValue> wallPoints = new ArrayList<>();
          static final int width = 60;
          static final int height = 60;
          static float maxValue = 50;
          static int randomValue = width - 2;
          static float[][] flow = new float[width][height];
          static boolean[][] flowSource = new boolean[width][height];

          public static void loadMap(PointValue self) {

                    // if we are near a point of safety in the map, go there
                    ArrayList<Point> safePlace = new ArrayList<>();


                    Point myself = null;
                    for (Person p : MapState.AllyMembers) {
                              if (p.getName().equals("Ahri")) {
                                        myself = new Point(p.getLocation());
                              } else {
                                        safePlace.add(new Point(p.getLocation()));
                              }
                    }

                    for (int i = 0; i < MapState.cyanTurrets.length; i++) {
                              Point place = new Point(MapData.cyanTowers[i]);
                              safePlace.add(place);
                              System.out.println(place);
                    }

                    if (myself == null) {
                              myself = new Point(MapState.view);

                    }

                    int least = -1;
                    Point place = null;
                    for (Point p : safePlace) {
                              if (myself.distance(p) < least || least == -1) {
                                        least = (int) myself.distance(p);
                                        place = new Point(p);
                              }
                    }
                    

                    if (false) // !!!!!!
                    {
                              if (least < 40) {
                                        ActionFormation.addAction(new Action(place, ActionFormation.ActionType.explore, ActionFormation.ActionForm.any, 2));

                                        return;
                              }
                    }

                    // else, just use the risk map
                    // for every point in our view, a direction is the "safety direction" and we want to reach it by going through the least amount of risk while doing so

                    flow = new float[width][height];
                    flowSource = new boolean[width][height];

                    dangerPoints.clear();
                    wallPoints.clear();

                    for (Point p : ViewState.EnemyBuildingsRisk) {
                              if (Mathematician.valid((int) Math.floor(p.getX()), (int) Math.floor(p.getY()), 60, 60)) {
                                        dangerPoints.add(new PointValue(p, (int) maxValue));
                              }
                    }
                    for (Point p : ViewState.EnemyCharactersRisk) {
                              if (Mathematician.valid((int) Math.floor(p.getX()), (int) Math.floor(p.getY()), 60, 60)) {
                                        dangerPoints.add(new PointValue(p, (int) maxValue / 2));
                              }
                    }
                    for (Point p : ViewState.EnemyMinionsRisk) {
                              if (Mathematician.valid((int) Math.floor(p.getX()), (int) Math.floor(p.getY()), 60, 60)) {
                                        dangerPoints.add(new PointValue(p, (int) maxValue / 3));
                              }
                    }

                    for (Point p : ViewState.WallRisk) {
                              p.x = p.x*60/1600;
                              p.y = p.y*60/900;
                              if (Mathematician.valid((int) Math.floor(p.getX()), (int) Math.floor(p.getY()), 60, 60)) {
                                        wallPoints.add(new PointValue(p, (int) 0));
                              }
                    }


                    // now create an influence that is generated by getting the distance of each pixel from a source
                    // and adding by distance

                    //
                    ArrayList<Point> escapePoints = new ArrayList<>();

                    // use place to see which escape Point is closer
                    // map view is 20x16
                    Point topLeft = new Point(MapState.view.x-10, MapState.view.y-8);
                    Point Left = new Point(MapState.view.x-10, MapState.view.y);
                    Point BottomLeft = new Point(MapState.view.x-10, MapState.view.y+8);
                    Point Bottom = new Point(MapState.view.x, MapState.view.y+8);
                    Point BottomRight = new Point(MapState.view.x+10, MapState.view.y+8);
                    escapePoints.add(topLeft);
                    escapePoints.add(Left);
                    escapePoints.add(BottomLeft);
                    escapePoints.add(Bottom);
                    escapePoints.add(BottomRight);
                    // now which is closest

                    double leastDistance = -1;
                    int escapePoint = 0;
                    for (int i=0;i<5;i++)
                    {
                              Point p = escapePoints.get(i);
                              
                              if (leastDistance == -1 || p.distance(place) < leastDistance) {
                                        escapePoint = i;
                                        leastDistance = p.distance(place);
                                        System.out.println("distance of "+p+" is "+leastDistance);
                              }
                    }
                    System.out.println("escape point"+escapePoint);



                    for (int i = 0; i < width; i++) {
                              for (int j = 0; j < height; j++) {
                                        flow[i][j] = 0;
                                        flowSource[i][j] = false;
                              }
                    }

                    for (PointValue p : dangerPoints) {
                              flowSource[(int) Math.floor(p.getX())][(int) Math.floor(p.getY())] = true;
                              flow[(int) Math.floor(p.getX())][(int) Math.floor(p.getY())] = p.getValue();
                    }

                    for (PointValue p : wallPoints) {

                              int radius = 1;
                              for (int i = -radius; i <= radius; i++) {
                                        for (int j = -radius; j <= radius; j++) {
                                                  
                                                  if (Mathematician.valid((int) Math.floor(p.getX()+i), (int) Math.floor(p.getY()+j), 60, 60)) 
                                                  {
                                                            flowSource[(int) Math.floor(p.getX() + i)][(int) Math.floor(p.getY() + j)] = true;
                                                  }
                                        }
                              }
                    }

                    BufferedImage bi2 = new BufferedImage(width * 5, height * 5, BufferedImage.TYPE_INT_RGB);
                    for (int iterations = 0; iterations < 20; iterations++) {
                              for (int i = 0; i < width * 5; i++) {
                                        for (int j = 0; j < height * 5; j++) {
                                                  int c;


                                                  c = Color.HSBtoRGB((flow[(int) Math.floor(i / 5)][(int) Math.floor(j / 5)]) / (maxValue), 1, 1);


                                                  if (flowSource[(int) Math.floor(i / 5)][(int) Math.floor(j / 5)]) {
                                                            c = Color.GREEN.getRGB();
                                                            if (flow[(int) Math.floor(i / 5)][(int) Math.floor(j / 5)] == 0) {
                                                                      c = Color.GRAY.getRGB();
                                                            }

                                                  }

                                                  bi2.setRGB(i, j, c);


                                        }
                              }

                              iterate();
                    }

                  //  ImageManipulator.show(bi2, 1);
            /*        try {
                              Thread.sleep(1000);
                    } catch (InterruptedException ex) {
                              Logger.getLogger(RiskMap.class.getName()).log(Level.SEVERE, null, ex);
                    }*/



                    // coordinate an evasive action based on A* and the points of best safety   

                    RiskNode start = null;
                    RiskNode end = null;
                    if (self.p != null) {
                              
                              // use realPosition, flow map and escapePoint to calculate next move
                              Point realPosition = new Point((int) (self.p.getX() * 60 / Actuator.viewWidth), (int) (self.p.getY() * 60 / Actuator.viewHeight));

                              // And now you only need to use A* to find a segmented path towards the goal
                              // the cost function is the flow of that place
                              // and the distance function is euclidian

                              // first we map the 60/60 grid into a 12x12 grid (/5)
                              
                              
                              RiskNode[][] nodeArray = new RiskNode[12][12];
                              for (int i = 0; i < 12; i++) {
                                        for (int j = 0; j < 12; j++) {                                                  
                                                  
                                                  boolean wall = false;
                                                  RiskNode n = new RiskNode();    
                                                  n.setX(i);
                                                  n.setY(j);
                                                  n.setType(1);
                                                  
                                                  
                                                  switch(escapePoint)
                                                  {
                                                            case 0: if (i == 0 && j ==0)
                                                                      end = n;
                                                                      n.setType(3); break;
                                                            case 1: if (i == 0 && j ==5)
                                                                      end = n;
                                                                      n.setType(3); break;
                                                            case 2: if (i == 0 && j ==11)
                                                                      end = n;
                                                                      n.setType(3); break;
                                                            case 3: if (i == 5 && j ==11)
                                                                      end = n;
                                                                      n.setType(3); break;
                                                            case 4: if (i == 11 && j ==11)
                                                                      end = n;
                                                                      n.setType(3); break;
                                                  }
                                                  
                                        /*          if (escapePoint.x*60/(Actuator.viewWidth*5) == i && escapePoint.y*60/(Actuator.viewHeight*5) == j)
                                                  {
                                                            end = n;
                                                            n.setType(3);               
                                                  }*/
                                                  
                                                  
                                                  if (realPosition.x/5 == i && realPosition.y/5 == j)
                                                  {                      
                                                            start = n;
                                                            n.setType(2);                  
                                                  }
                                                            
                                                          
                                                  

                                                          
                                                  int myFlow = 0;
                                                  {
                                                            for (int k1 = 0; k1 < 5; k1++) {
                                                                      for (int k2 = 0; k2 < 5; k2++) {
                                                                                // it's a wall
                                                                                if (flowSource[i*5 + k1][j*5 + k2] && flow[i*5 + k1][j*5 + k2] == 0) { // if not wall node add it
                                                                                          wall = true;
                                                                                }

                                                                                myFlow += flow[i*5 + k1][j*5 + k2];

                                                                      }

                                                                      
                                                            }
                                                            
                                                  }   
                                                  
                                                  if (!wall)
                                                  {
                                                                      n.setFlow(1+myFlow/(25f*maxValue)); // from 1 (if mean is 0) to 2 (if mean is maxValue)
                                                                      nodeArray[i][j] = n;
                                                  }
                                        }
                              }
                                               
                              /*
                              for (int j = 0; j < 12; j++) {
                                        for (int i = 0; i < 12; i++) {          
                                                  if (nodeArray[i][j] == null)
                                                            System.out.print("O   ");
                                                  else
                                                  switch (nodeArray[i][j].getType())
                                                  {
                                                            case 1: System.out.print(String.format("%.01f", nodeArray[i][j].getFlow())+" "); break;
                                                            case 2: System.out.print("S   "); break;
                                                            case 3: System.out.print("X   "); break;
                                                  }
                                        }
                                        System.out.println();
                              }*/
                              
                              // Now perform the a star search on the node array
                              ArrayList<RiskNode> closedSet = new ArrayList<>();
                              ArrayList<RiskNode> openSet = new ArrayList<>();
                              ArrayList<RiskNode> finalPath = new ArrayList<>();
                              
                              openSet.add(start);
                              start.setGscore(0);
                              start.findFscore(end);
                              end.setGscore(0);
                              
                              boolean foundPath = false;
                              while(openSet.size() > 0)
                              {
                                        RiskNode current = Astar.findCurrentNode(openSet);
                                        if (current.getX() == end.getX() && current.getY() == end.getY())
                                        {
                                                  foundPath = true;
                                                  break;
                                        }
                                        
                                        openSet.remove(current);
                                        closedSet.add(current);
                                        
                                        // for all neighbour nodes of current
                                        // if !closed set
                                        ArrayList<RiskNode> interestNodes = new ArrayList<>();
                                        
                                        if (current.getX()>0 && nodeArray[current.getX()-1][current.getY()] != null)
                                                  interestNodes.add(nodeArray[current.getX()-1][current.getY()]);
                                        if (current.getX()<11 && nodeArray[current.getX()+1][current.getY()] != null)
                                                  interestNodes.add(nodeArray[current.getX()+1][current.getY()]);
                                        if (current.getY()>0 && nodeArray[current.getX()][current.getY()-1] != null)
                                                  interestNodes.add(nodeArray[current.getX()][current.getY()-1]);
                                        if (current.getY()<11 && nodeArray[current.getX()][current.getY()+1] != null)
                                                  interestNodes.add(nodeArray[current.getX()][current.getY()+1]);
                                                                                
                                        
                                        for (RiskNode r : interestNodes)
                                        {
                                                  float tentativeGscore;
                                                  if (closedSet.contains(r))
                                                            continue;
                                                  
                                                  tentativeGscore = current.getGscore() + r.getFlow();
                                                  
                                                  // is this or
                                                  if (!openSet.contains(r) || tentativeGscore < r.getGscore())
                                                  {
                                                            r.setCameFrom(current);
                                                            current.setWentTo(r);
                                                            r.setGscore(tentativeGscore);
                                                            r.findFscore(end);
                                                            if (!openSet.contains(r))
                                                                      openSet.add(r);
                                                  }
                                                  
                                        }
                                        
                              }
                              if (!foundPath)
                              {
                                       // System.out.println("Failure");
                                    //    System.out.println("ahri is at "+start.getX()+" "+start.getY()+" wants to go to "+end.getX()+" "+end.getY());
                              }
                              else
                              {
                                     //   System.out.println("ahri is at "+start.getX()+" "+start.getY()+" wants to go to "+end.getX()+" "+end.getY());
                                        RiskNode n = end;
                                        while (n != start)
                                        {
                                                  System.out.println(n.getX()+" "+n.getY());
                                                  
                                                  n = n.getCameFrom();
                                        }
                                        
                                    //    System.out.println(n.getX()+" "+n.getY());
                              }
                              
                              if (foundPath)
                              {
                              RiskNode begin = start;
                              for (int i=0;i<4;i++)
                              {                                        
                                        if (begin.getWentTo() != null)
                                        {
                                                  begin = begin.getWentTo();
                                                  continue;
                                        }
                                        else
                                                  break;
                              }
                              
                            //  System.out.println("would like to go to "+begin.getX()+" "+begin.getY());


                             // System.out.println(begin.getX()*5*Actuator.viewWidth/60f);
                              Point riskFinalPosition = new Point((int)(begin.getX()*5*Actuator.viewWidth/60f),(int)(begin.getY()*5*Actuator.viewHeight/60f));
                              ActionFormation.addAction(new Action(riskFinalPosition, ActionFormation.ActionType.approach, ActionFormation.ActionForm.any, 2));
                              }
                    }
                    //


          }

          private static void iterate() {

                    Random r = new Random();
                    for (int k = 0; k < width * height * 2; k++) {

                              int i = r.nextInt(randomValue) + 1;
                              int j = r.nextInt(randomValue) + 1;



                              if (!flowSource[i][j]) {
                                        float xa = flow[i - 1][j];
                                        float xb = flow[i + 1][j];

                                        float dxa = flow[i + 1][j + 1];
                                        float dxb = flow[i + 1][j + 1];

                                        float ya = flow[i][j - 1];
                                        float yb = flow[i][j + 1];

                                        float dya = flow[i + 1][j - 1];
                                        float dyb = flow[i + 1][j - 1];

                                        float max = Math.max(Math.max(Math.max(ya, yb), Math.max(xa, xb)), Math.max(Math.max(dya, dyb), Math.max(dxa, dxb)));

                                        flow[i][j] = max - 1;
                              }




                    }

          }
}
